# 42번째 만남

### WIL

- enum type을 string union으로 바꾸는 것 도전
  ```ts
  enum Fruit {
    apple = 'apple'
  }
  const fruit:Fruit = 'apple' // error
  const fruit2:Fruit = Fruit.apple // pass

  type FruitType = `${Fruit}`; // enum의 값들에 대한 타입을 만들 수 있다.
  ```
  - microsoft/typescript 이슈 `Allow "T extends enum" generic constraint`  
    하지만 allow된 상태는 아니다. enum extends 하는 것 불가능
  - 그럼 구현해보자.
    ```ts
    type isEnum<T> = Equal<keyof T, keyof string> extends true? true : false;
    ```
  - 테스트해봤을 때 완벽하지는 않다.
- 최고의 팁은 multi-pass rendering(ex. use(Layout)Effect에서 setState)을 피하는 것
  - 예를 들어 useEffect 내에서 fetchData 한 다음 -> setState 하지 말고 / 컴포넌트 상단에서 fetchData하고 그 데이터를 초깃값으로 할당해주는 것이 더 낫다.
  - multi-pass란?
    - `pass` 단위 : 컴포넌트가 호출이 될 때 쭉 아래로 JSX가 반환되는 그 과정 하나
    - useEffect에서 setState하면 상태가 한 번 더 리렌더링된다. -> 그럼 multi-pass
  - 컴포넌트가 multi-pass 되면 데이터 변화를 추적하기가 힘들어진다.
  - 성능상 문제가 될 수 있지만, 성능상 문제가 되지 않더라도 가급적이면 multi-pass rendering을 피하면 좀 더 읽기 쉬운 코드를 작성할 수 있다.
- Context API
  - Provider로 주입하는 상태가 update되면 **그 상태를 구독하는 컴포넌트만 re-render 된다** vs 하위 컴포넌트는 모두 re-render 된다
  - -> 그 상태를 구독하는 컴포넌트만 re-render 되는 것이 맞다.
  - 의견1: 원래 하위 컴포넌트 모두 re-render되었는데, 수정된 것 같다. RFC에서 본 것 같다.
  - 의견2: react 측에서 상태 관리 라이브러리에 사용하려 한 API(useExternalStore)를 export해줬는데, 자기네들이 만든 context에 이를 넣지 않을 이유가 없다.
  - 그럼 recoil을 쓰는 이유가 무엇일까
    - https://github.com/dai-shi/use-context-selector
    - 상태가 많아지면 context를 여러 개 써야 하고, 그럼 Provider가 매우 복잡해질 수 있기 때문이다.
- 그럼 정확히 컴포넌트가 re-render되는 조건이 뭐야?
  - 이 문제로 고통받고 있다...
  - 페이지가 render phase / commit phase로 나뉜다.
    - render phase : re-render -> VDOM Element를 만드는 순간
    - commit phase : reconciliation -> 실제 DOM
  - re-rendering이 일어났는데 실제 DOM에 반영 안 되는 경우가 있다. 
  - https://blog.bitsrc.io/how-react-renders-a-component-on-screen-da97c56caf71
  - **1. 주입 받는 prop이 변경되는가 / 2. 구독하는 state가 변경되는가 / 3. forceRender**
- React.memo를 왜 쓰는걸까?
  - rendering한 결과물을 memoization
  - state와 props에 따라서 key와 value의 형태로 메모리에 저장해놔서, 리렌더링하면 그 조건에 해당하는 key값으로 가져오기 위해 쓰는 것 같다.
  - https://ui.toast.com/weekly-pick/ko_20190731
  - 그럼 보통 서버에서 받아온 데이터를 `array.map`하면서 최적화한다고 memo로 많이 감싸는데, 그 아이템에 key prop을 쓰는 것을 통한 최적화와 어떤 부분이 다른가
    - key prop은 최적화하는 관점이 다르다. 
      - diffing algorithm과 함께 나오는 이야기
      - key를 주면 배열 재정렬 시간복잡도를 줄일 수 있다.
      - 즉 memo는 렌더링된 결과값을 메모하는 거고, key는 diffing과 연관있는 것
    - 그럼 전혀 다른 컴포넌트인데 key prop이 같으면?
      - key props는 sibling끼리만 다르면 된다.
      - sibling끼리 같으면 렌더링 이상하게 됨

### 잡담

- 인규님 에어컨 집들이 다음날 새로 설치하심 (100만원짜리)
- https://github.com/velopert/sangte 컨트리븉 해요 ~!

---

- 📆 2022.09.26 20:20 ~ 21:30
- 👥 [@Seogeurim](https://github.com/Seogeurim) [@pumpkiinbell](https://github.com/pumpkiinbell) 
[@jiyong1](https://github.com/jiyong1) [@KangyeolLee](https://github.com/KangyeolLee) [@gomjellie](https://github.com/gomjellie)
